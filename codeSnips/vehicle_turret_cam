
					indiCam_var_cameraType = "logics";
					indiCam_var_disqualifyScene = false; // If true, this scene will not be applied and a new one will be selected
					indiCam_var_takeTime = 10;
					indiCam_var_cameraMovementRate = 0;
					indiCam_var_cameraPos = (vehicle actor) modelToWorld [0,0,2];
					indiCam_var_cameraTarget = indiCam_weaponLogic;
					indiCam_var_cameraFov = 0.7;
					indiCam_var_maxDistance = 100;
					indiCam_var_ignoreHiddenActor = false;
					// Control wether the camera should be attached to anything
					indiCam_var_cameraAttach = true;
					indiCam attachTo [(vehicle actor), [0,-5,2]];
					// Start up any necessary logic entities
					[20] spawn indiCam_cameraLogic_vehicleTurret; // [distance]











logic = createVehicle ["Sign_Sphere100cm_F", getpos actor, [], 0, "CAN_COLLIDE"];

doit = true;
while {doit} do {
_weaponHandPos = getPos (vehicle actor);
_weaponDirection = vectorNormalized ((vehicle actor) weaponDirection currentWeapon (vehicle actor));
_weaponLogicVector = _weaponDirection vectorMultiply 20;
_weaponLogicPos = _weaponHandPos vectorAdd _weaponLogicVector;
drawLine3D [_weaponHandPos,_weaponLogicPos, [1,1,0,1]];
logic setPos _weaponLogicPos;
sleep 0.1;
};












while {true} do {
_weaponVectorDir = (vehicle player) weaponDirection currentWeapon (vehicle player);
hint str _weaponVectorDir;
};














tank = (vehicle dude);

KK_fnc_weaponDirRelative = {
    private "_veh";
    _veh = _this select 0;
    _veh worldToModelVisual (_veh weaponDirection (_this select 1))
    vectorDiff
    (_veh worldToModelVisual [0,0,0])
};

hint str ([tank, "cannon_105mm"] call KK_fnc_weaponDirRelative);